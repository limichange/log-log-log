# 小程序的高性能

页面能否正常访问？ 首次内容绘制 (First Contentful Paint, FCP)
页面内容是否有用？ 首次有效绘制 (First Meaningful Paint, FMP)
页面功能是否可用？ 可交互时间 (Time to Interactive, TTI)

微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。

而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了双线程模型：

视图层：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；
逻辑层：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；

PurifyCSS

部分页面 h5 化

wx.getBackgroundFetchData

对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。

- 1.  准备新的 webview 线程环境，包括基础库的初始化；
- 2.  从逻辑层到视图层的初始数据通信；
- 3.  视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；

由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信 和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是：

降低线程间通信频次；
减少线程间通信的数据量；
减少 WXML 节点数量；

事件总线，替代组件间数据绑定的通信方式

onPageScroll 事件回调使用节流；
避免 CPU 密集型操作，譬如复杂的计算；
避免调用 setData，或减小 setData 的数据量；
尽量使用 IntersectionObserver[24] 来替代 SelectorQuery[25]，前者对性能影响更小；

## links

- [京喜小程序的高性能打造之路](https://mp.weixin.qq.com/s/nXModRImp4H7iisMQSc2Wg)
