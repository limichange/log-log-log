# 浏览器主线程常驻线程

## GUI 渲染线程

绘制页面，解析 HTML、CSS，构建 DOM 树，布局和绘制等
页面重绘和回流
与 JS 引擎线程互斥，也就是所谓的 JS 执行阻塞页面更新

## JS 引擎线程

负责 JS 脚本代码的执行
负责准执行准备好待执行的事件，即定时器计数结束，或异步请求成功并正确返回的事件
与 GUI 渲染线程互斥，执行时间过长将阻塞页面的渲染

这里特指 Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个渲染线程，GUI 渲染和 Javascript 执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。

## 事件触发线程

负责将准备好的事件交给 JS 引擎线程执行
多个事件加入任务队列的时候需要排队等待(JS 的单线程)

## 定时器触发线程

负责执行异步的定时器类的事件，如 setTimeout、setInterval
定时器到时间之后把注册的回调加到任务队列的队尾

## HTTP 请求线程

负责执行异步请求
主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调函数加入到任务队列的队尾等待执行

# 浏览器端的 Event Loop

- Call Stack：调用栈(执行栈)，所有同步任务在主线程上执行，形成一个执行栈，因为 JS 单线程的原因，所以调用栈中每次只能执行一个任务，当遇到的同步任务执行完之后，由任务队列提供任务给调用栈执行。
- Task Queue：任务队列，存放着异步任务，当异步任务可以执行的时候，任务队列会通知主线程，然后该任务会进入主线程执行。任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中。

## 事件运行顺序

- 执行同步任务，同步任务不需要做特殊处理，直接执行(下面的步骤中遇到同步任务都是一样处理) --- 第一轮从 script 开始
- 从宏任务队列中取出队头任务执行
- 如果产生了宏任务，将宏任务放入宏任务队列，下次轮循的时候执行
- 如果产生了微任务，将微任务放入微任务队列
- 执行完当前宏任务之后，取出微任务队列中的所有任务依次执行
- 如果微任务执行过程中产生了新的微任务，则继续执行微任务，直到微任务的队列为空
  轮循，循环以上 2 - 6

## links

- [浏览器主线程常驻线程](https://mp.weixin.qq.com/s/yNyBWZqTiLSqvscNXDaaPw)
