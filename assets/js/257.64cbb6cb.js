(window.webpackJsonp=window.webpackJsonp||[]).push([[257],{601:function(t,e,s){"use strict";s.r(e);var a=s(43),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"setstate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),s("p",[t._v("在 React 的生命周期和合成事件中， React 仍然处于他的更新机制中，这时无论调用多少次 setState，都会不会立即执行更新，而是将要更新的·存入 _pendingStateQueue，将要更新的组件存入 dirtyComponent。")]),t._v(" "),s("p",[t._v("setState 本身并不是异步的，而是 React 的批处理机制给人一种异步的假象。")]),t._v(" "),s("p",[t._v("setState 的第二个参数接收一个函数，该函数会在 React 的批处理机制完成之后调用，所以你想在调用 setState 后立即获取更新后的值，请在该回调函数中获取。")]),t._v(" "),s("p",[t._v("React 会对多次连续的 setState 进行合并，如果你想立即使用上次 setState 后的结果进行下一次 setState，可以让 setState 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。")]),t._v(" "),s("h2",{attrs:{id:"links"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),s("ul",[s("li",[t._v("https://mp.weixin.qq.com/s/vJOAiiP0PSMOgPStZw-rQA")])])])}),[],!1,null,null,null);e.default=n.exports}}]);