(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{482:function(e,s,t){"use strict";t.r(s);var r=t(43),a=Object(r.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("p",[e._v("promise.all")]),e._v(" "),t("p",[e._v("Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。")]),e._v(" "),t("p",[e._v("Promise 在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环。\n关于 Promise 在事件循环中还有一个 微任务的概念（microtask），感兴趣的话可以看我这篇关于 nodejs 时间循环的文章 剖析 nodejs 的事件循环，虽然和浏览器端有些不同，但是 Promise 微任务的执行时机相差不大。")]),e._v(" "),t("h2",{attrs:{id:"questions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#questions"}},[e._v("#")]),e._v(" questions")]),e._v(" "),t("ul",[t("li",[e._v("promise 定义时传入的函数什么时候执行的？")]),e._v(" "),t("li",[e._v("promise.all？如何实现一个链式异步请求，一个请求完成继续下一个请求?then 链式执行呗。中间如果有一个 promise 出错怎么办？如何确保执行到最后？我答的还是 try catch 前行 resolve，不过好像不太对，有知道的大神求指导。")])]),e._v(" "),t("h2",{attrs:{id:"links"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" links")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/5b31a4b7f265da595725f322",target:"_blank",rel:"noopener noreferrer"}},[e._v("面试精选之 Promise"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=a.exports}}]);