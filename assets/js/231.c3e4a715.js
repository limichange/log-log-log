(window.webpackJsonp=window.webpackJsonp||[]).push([[231],{575:function(t,e,r){"use strict";r.r(e);var s=r(43),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"tcp-为什么需要-3-次握手与-4-次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp-为什么需要-3-次握手与-4-次挥手"}},[t._v("#")]),t._v(" TCP 为什么需要 3 次握手与 4 次挥手")]),t._v(" "),r("h2",{attrs:{id:"为什么需要-三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-三次握手"}},[t._v("#")]),t._v(" 为什么需要“三次握手”")]),t._v(" "),r("p",[t._v("在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。")]),t._v(" "),r("p",[t._v("主要目的防止 server 端一直等待，浪费资源。")]),t._v(" "),r("p",[t._v("本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。")]),t._v(" "),r("h2",{attrs:{id:"为什么需要-四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-四次挥手"}},[t._v("#")]),t._v(" 为什么需要“四次挥手”")]),t._v(" "),r("p",[t._v("那可能有人会有疑问，在 tcp 连接握手时为何 ACK 是和 SYN 一起发送，这里 ACK 却没有和 FIN 一起发送呢。原因是因为 tcp 是全双工模式，接收到 FIN 时意味将没有数据再发来，但是还是可以继续发送数据。")]),t._v(" "),r("p",[t._v("当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。")]),t._v(" "),r("h2",{attrs:{id:"links"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/xifeijian/article/details/12777187",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP 为什么需要 3 次握手与 4 次挥手"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);