(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{414:function(t,a,_){"use strict";_.r(a);var v=_(43),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"在浏览器输入-url-回车之后发生了什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器输入-url-回车之后发生了什么"}},[t._v("#")]),t._v(" 在浏览器输入 URL 回车之后发生了什么")]),t._v(" "),_("h2",{attrs:{id:"大致流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大致流程"}},[t._v("#")]),t._v(" 大致流程")]),t._v(" "),_("ul",[_("li",[t._v("URL 解析")]),t._v(" "),_("li",[t._v("DNS 查询")]),t._v(" "),_("li",[t._v("TCP 连接")]),t._v(" "),_("li",[t._v("处理请求")]),t._v(" "),_("li",[t._v("接受响应")]),t._v(" "),_("li",[t._v("渲染页面")])]),t._v(" "),_("h2",{attrs:{id:"一、url-解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、url-解析"}},[t._v("#")]),t._v(" 一、URL 解析")]),t._v(" "),_("ul",[_("li",[t._v("首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。")]),t._v(" "),_("li",[t._v("浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。")])]),t._v(" "),_("h2",{attrs:{id:"二、dns-查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、dns-查询"}},[t._v("#")]),t._v(" 二、DNS 查询")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("#")]),t._v(" "),_("th",[t._v("查询流程")]),t._v(" "),_("th",[t._v("解释")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1")]),t._v(" "),_("td",[t._v("浏览器缓存")]),t._v(" "),_("td",[t._v("浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询")])]),t._v(" "),_("tr",[_("td",[t._v("2")]),t._v(" "),_("td",[t._v("操作系统缓存")]),t._v(" "),_("td",[t._v("操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求")])]),t._v(" "),_("tr",[_("td",[t._v("3")]),t._v(" "),_("td",[t._v("路由器缓存")]),t._v(" "),_("td",[t._v("路由器也有自己的缓存")])]),t._v(" "),_("tr",[_("td",[t._v("4")]),t._v(" "),_("td",[t._v("ISP DNS 缓存")]),t._v(" "),_("td",[t._v("ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存")])]),t._v(" "),_("tr",[_("td",[t._v("5")]),t._v(" "),_("td",[t._v("根域名服务器查询")]),t._v(" "),_("td",[t._v("在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域")])])])]),t._v(" "),_("h2",{attrs:{id:"三、tcp-连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、tcp-连接"}},[t._v("#")]),t._v(" 三、TCP 连接")]),t._v(" "),_("p",[t._v("TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装")]),t._v(" "),_("h3",{attrs:{id:"应用层：发送-http-请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用层：发送-http-请求"}},[t._v("#")]),t._v(" 应用层：发送 HTTP 请求")]),t._v(" "),_("p",[t._v("在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括")]),t._v(" "),_("ul",[_("li",[t._v("请求报头（Request Header）：请求方法、目标地址、遵循的协议等等")]),t._v(" "),_("li",[t._v("请求主体（其他参数）")])]),t._v(" "),_("h3",{attrs:{id:"传输层：tcp-传输报文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输层：tcp-传输报文"}},[t._v("#")]),t._v(" 传输层：TCP 传输报文")]),t._v(" "),_("p",[t._v("传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。")]),t._v(" "),_("p",[t._v("在建立连接前，会先进行 TCP 三次握手。")]),t._v(" "),_("h4",{attrs:{id:"三次握手-ヽ-ｰ-人-ｰ-ノ"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手-ヽ-ｰ-人-ｰ-ノ"}},[t._v("#")]),t._v(" 三次握手 ヽ("),_("em",[t._v("^ｰ^)人(^ｰ^")]),t._v(")ノ")]),t._v(" "),_("p",[t._v("为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？")]),t._v(" "),_("p",[t._v("建立连接的过程是利用客户服务器模式，假设主机 A 为客户端，主机 B 为服务器端。\n采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B，因而产生错误。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。\n采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client 和 server 都有一个发 syn 和收 ack 的过程， 双方都是发后能收， 表明通信则准备工作 OK.\n为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能 100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。")]),t._v(" "),_("h3",{attrs:{id:"网络层：ip-协议查询-mac-地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络层：ip-协议查询-mac-地址"}},[t._v("#")]),t._v(" 网络层：IP 协议查询 Mac 地址")]),t._v(" "),_("p",[t._v("将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。")]),t._v(" "),_("p",[t._v("判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。")]),t._v(" "),_("h3",{attrs:{id:"链路层：以太网协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链路层：以太网协议"}},[t._v("#")]),t._v(" 链路层：以太网协议")]),t._v(" "),_("h4",{attrs:{id:"以太网协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#以太网协议"}},[t._v("#")]),t._v(" 以太网协议")]),t._v(" "),_("p",[t._v("根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：")]),t._v(" "),_("ul",[_("li",[t._v("标头：数据包的发送者、接受者、数据类型")]),t._v(" "),_("li",[t._v("数据：数据包具体内容")])]),t._v(" "),_("h4",{attrs:{id:"mac-地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mac-地址"}},[t._v("#")]),t._v(" Mac 地址")]),t._v(" "),_("p",[t._v("以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。")]),t._v(" "),_("h3",{attrs:{id:"服务器接受请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务器接受请求"}},[t._v("#")]),t._v(" 服务器接受请求")]),t._v(" "),_("p",[t._v("接受过程就是把以上步骤逆转过来")]),t._v(" "),_("h2",{attrs:{id:"四、服务器处理请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、服务器处理请求"}},[t._v("#")]),t._v(" 四、服务器处理请求")]),t._v(" "),_("p",[t._v("处理端口请求的数据。匹配路径。")]),t._v(" "),_("h3",{attrs:{id:"httpd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#httpd"}},[t._v("#")]),t._v(" HTTPD")]),t._v(" "),_("h2",{attrs:{id:"五、浏览器接受相应"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、浏览器接受相应"}},[t._v("#")]),t._v(" 五、浏览器接受相应")]),t._v(" "),_("p",[t._v("浏览器接收到来自服务器的响应资源后，会对资源进行分析。\n首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。\n如果响应资源进行了压缩（比如 gzip），还需要进行解压。\n然后，对响应资源做缓存。\n接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。")]),t._v(" "),_("h2",{attrs:{id:"六、渲染页面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、渲染页面"}},[t._v("#")]),t._v(" 六、渲染页面")]),t._v(" "),_("p",[t._v("解析 —— HTML，CSS，JS\n渲染 —— 构建 DOM 树 -> 渲染 -> 布局 -> 绘制")]),t._v(" "),_("h3",{attrs:{id:"_1-html-解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-html-解析"}},[t._v("#")]),t._v(" 1 HTML 解析")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("过程")]),t._v(" "),_("th",[t._v("详解")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("解码（encoding）")]),t._v(" "),_("td",[t._v("传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。")])]),t._v(" "),_("tr",[_("td",[t._v("预解析（pre-parsing）")]),t._v(" "),_("td",[t._v("预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如 img 标签的 src 属性，并将这个请求加到请求队列中。")])]),t._v(" "),_("tr",[_("td",[t._v("符号化（Tokenization）")]),t._v(" "),_("td",[t._v("符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。它通过一个状态机去识别符号的状态，比如遇到<，>状态都会产生变化。")])]),t._v(" "),_("tr",[_("td",[t._v("构建树（tree construction）")]),t._v(" "),_("td",[t._v("符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。")])])])]),t._v(" "),_("p",[t._v("当整个解析的过程完成以后，浏览器会通过 DOMContentLoaded 事件来通知 DOM 解析完成。")]),t._v(" "),_("h3",{attrs:{id:"_2-css-解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-css-解析"}},[t._v("#")]),t._v(" 2 CSS 解析")]),t._v(" "),_("p",[t._v("一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。")]),t._v(" "),_("h3",{attrs:{id:"_3-渲染树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-渲染树"}},[t._v("#")]),t._v(" 3 渲染树")]),t._v(" "),_("p",[t._v("其实这就是一个 DOM 树和 CSS 规则树合并的过程。")]),t._v(" "),_("h4",{attrs:{id:"渲染阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染阻塞"}},[t._v("#")]),t._v(" 渲染阻塞")]),t._v(" "),_("ul",[_("li",[t._v("CSS 会阻塞 JS 执行")]),t._v(" "),_("li",[t._v("JS 会阻塞后面的 DOM 解析")])]),t._v(" "),_("h4",{attrs:{id:"计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算"}},[t._v("#")]),t._v(" 计算")]),t._v(" "),_("ul",[_("li",[t._v("通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把 rem 转化为 px。")])]),t._v(" "),_("h3",{attrs:{id:"_4-布局与绘制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-布局与绘制"}},[t._v("#")]),t._v(" 4 布局与绘制")]),t._v(" "),_("p",[t._v("确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。\n然后遍历渲染树，调用渲染器的 "),_("code",[t._v("paint()")]),t._v(" 方法在屏幕上显示其内容。")]),t._v(" "),_("h3",{attrs:{id:"_5-合并渲染层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-合并渲染层"}},[t._v("#")]),t._v(" 5 合并渲染层")]),t._v(" "),_("p",[t._v("把以上绘制的所有图片合并，最终输出一张图片。")]),t._v(" "),_("h3",{attrs:{id:"_6-回流与重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-回流与重绘"}},[t._v("#")]),t._v(" 6 回流与重绘")]),t._v(" "),_("h4",{attrs:{id:"回流-reflow"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[t._v("#")]),t._v(" 回流(reflow)")]),t._v(" "),_("p",[t._v("当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从 html 标签开始递归往下，重新计算位置和大小。")]),t._v(" "),_("p",[t._v("reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。")]),t._v(" "),_("h4",{attrs:{id:"重绘-repaint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[t._v("#")]),t._v(" 重绘(repaint)")]),t._v(" "),_("p",[t._v("改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。")]),t._v(" "),_("p",[t._v("每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。")]),t._v(" "),_("p",[t._v("回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。")]),t._v(" "),_("p",[_("code",[t._v("display:none 会触发回流，而 visibility:hidden 只会触发重绘。")])]),t._v(" "),_("h3",{attrs:{id:"_7-javascript-编译执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-javascript-编译执行"}},[t._v("#")]),t._v(" 7 JavaScript 编译执行")]),t._v(" "),_("h4",{attrs:{id:"词法分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#词法分析"}},[t._v("#")]),t._v(" 词法分析")]),t._v(" "),_("p",[t._v("JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。")]),t._v(" "),_("h4",{attrs:{id:"预编译"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#预编译"}},[t._v("#")]),t._v(" 预编译")]),t._v(" "),_("p",[t._v("JS 有三种运行环境：")]),t._v(" "),_("ul",[_("li",[t._v("全局环境")]),t._v(" "),_("li",[t._v("函数环境")]),t._v(" "),_("li",[t._v("eval")])]),t._v(" "),_("p",[t._v("每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。\n创建执行上下文的过程中，主要做了以下三件事：")]),t._v(" "),_("ul",[_("li",[t._v("创建变量对象\n"),_("ul",[_("li",[t._v("参数、函数、变量")])])]),t._v(" "),_("li",[t._v("建立作用域链\n"),_("ul",[_("li",[t._v("确认当前执行环境是否能访问变量")])])]),t._v(" "),_("li",[t._v("确定 This 指向")])]),t._v(" "),_("h4",{attrs:{id:"执行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行"}},[t._v("#")]),t._v(" 执行")]),t._v(" "),_("ul",[_("li",[t._v("JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎")]),t._v(" "),_("li",[t._v("事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行")]),t._v(" "),_("li",[t._v("定时器触发线程：主要控制 setInterval 和 setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。")]),t._v(" "),_("li",[t._v("HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。")])]),t._v(" "),_("h2",{attrs:{id:"links"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://juejin.im/post/5d5e795ff265da03e275f29e",target:"_blank",rel:"noopener noreferrer"}},[t._v("在浏览器输入 URL 回车之后发生了什么"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://segmentfault.com/a/1190000006879700",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端经典面试题: 从输入 URL 到页面加载发生了什么？"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/skyline75489/what-happens-when-zh_CN",target:"_blank",rel:"noopener noreferrer"}},[t._v("What-happens-when 的中文翻译"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/43369093",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器输入 URL 后发生了什么？"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);