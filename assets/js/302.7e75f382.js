(window.webpackJsonp=window.webpackJsonp||[]).push([[302],{647:function(t,e,v){"use strict";v.r(e);var n=v(43),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"小程序的高性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小程序的高性能"}},[t._v("#")]),t._v(" 小程序的高性能")]),t._v(" "),v("p",[t._v("页面能否正常访问？ 首次内容绘制 (First Contentful Paint, FCP)\n页面内容是否有用？ 首次有效绘制 (First Meaningful Paint, FMP)\n页面功能是否可用？ 可交互时间 (Time to Interactive, TTI)")]),t._v(" "),v("p",[t._v("微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。")]),t._v(" "),v("p",[t._v("而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了双线程模型：")]),t._v(" "),v("p",[t._v("视图层：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；\n逻辑层：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；")]),t._v(" "),v("p",[t._v("PurifyCSS")]),t._v(" "),v("p",[t._v("部分页面 h5 化")]),t._v(" "),v("p",[t._v("wx.getBackgroundFetchData")]),t._v(" "),v("p",[t._v("对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。")]),t._v(" "),v("ul",[v("li",[v("ol",[v("li",[t._v("准备新的 webview 线程环境，包括基础库的初始化；")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[t._v("从逻辑层到视图层的初始数据通信；")])])]),t._v(" "),v("li",[v("ol",{attrs:{start:"3"}},[v("li",[t._v("视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；")])])])]),t._v(" "),v("p",[t._v("由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信 和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是：")]),t._v(" "),v("p",[t._v("降低线程间通信频次；\n减少线程间通信的数据量；\n减少 WXML 节点数量；")]),t._v(" "),v("p",[t._v("事件总线，替代组件间数据绑定的通信方式")]),t._v(" "),v("p",[t._v("onPageScroll 事件回调使用节流；\n避免 CPU 密集型操作，譬如复杂的计算；\n避免调用 setData，或减小 setData 的数据量；\n尽量使用 IntersectionObserver[24] 来替代 SelectorQuery[25]，前者对性能影响更小；")]),t._v(" "),v("p",[t._v("大图、长列表优化\n据 小程序官方文档[26] 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。")]),t._v(" "),v("p",[t._v("对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。")]),t._v(" "),v("p",[t._v("对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver[27] 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。")]),t._v(" "),v("p",[t._v("然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。")]),t._v(" "),v("p",[t._v("小程序官方提供了一个 长列表组件[28]，可以通过 npm 包的方式引入，有兴趣的可以尝试。")]),t._v(" "),v("h2",{attrs:{id:"links"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://mp.weixin.qq.com/s/nXModRImp4H7iisMQSc2Wg",target:"_blank",rel:"noopener noreferrer"}},[t._v("京喜小程序的高性能打造之路"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);