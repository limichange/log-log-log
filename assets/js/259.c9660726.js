(window.webpackJsonp=window.webpackJsonp||[]).push([[259],{603:function(e,t,s){"use strict";s.r(t);var f=s(43),a=Object(f.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"useeffect-和-uselayouteffect-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#useeffect-和-uselayouteffect-的区别"}},[e._v("#")]),e._v(" useEffect 和 useLayoutEffect 的区别")]),e._v(" "),s("p",[e._v("useLayoutEffect 的作用和 useEffect 几乎差不多，你把你现有代码的 useEffect 全部替换成 useLayoutEffect，你几乎看不到任何差别。")]),e._v(" "),s("p",[e._v("相比使用 useEffect，当你点击 div，count 更新为 0，此时页面并不会渲染，而是等待 useLayoutEffect 内部状态修改后，才会去更新页面，所以页面不会闪烁。")]),e._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("ul",[s("li",[e._v("useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。")]),e._v(" "),s("li",[e._v("useEffect 可以满足百分之 99 的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。")])]),e._v(" "),s("h2",{attrs:{id:"other"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[e._v("#")]),e._v(" other")]),e._v(" "),s("ul",[s("li",[e._v("useEffect 在全部渲染完毕后才会执行")]),e._v(" "),s("li",[e._v("useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行")]),e._v(" "),s("li",[e._v("其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect")]),e._v(" "),s("li",[e._v("可以使用它来读取 DOM 布局并同步触发重渲染")]),e._v(" "),s("li",[e._v("尽可能使用标准的 useEffect 以避免阻塞视图更新")])]),e._v(" "),s("h2",{attrs:{id:"links"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" links")]),e._v(" "),s("p",[e._v("-"),s("a",{attrs:{href:"https://juejin.im/post/5de38c76e51d455f9b335eff",target:"_blank",rel:"noopener noreferrer"}},[e._v("useEffect 和 useLayoutEffect 的区别"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);