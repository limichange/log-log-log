(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{435:function(t,e,s){"use strict";s.r(e);var n=s(43),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"了解-v8-引擎吗，一段-js-代码如何执行的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#了解-v8-引擎吗，一段-js-代码如何执行的"}},[t._v("#")]),t._v(" 了解 v8 引擎吗，一段 js 代码如何执行的")]),t._v(" "),s("p",[t._v("在执行一段代码时，JS 引擎会首先创建一个执行栈")]),t._v(" "),s("p",[t._v("然后 JS 引擎会创建一个全局执行上下文，并 push 到执行栈中, 这个过程 JS 引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS 引擎会进入执行阶段，这个过程 JS 引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。")]),t._v(" "),s("p",[t._v("如果这段代码中存在 function 的声明和调用，那么 JS 引擎会创建一个函数执行上下文，并 push 到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS 引擎会在父函数执行的过程中，将子函数的全局执行上下文 push 到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。")]),t._v(" "),s("p",[t._v("还有一种特殊情况是，在子函数执行的过程中，父函数已经 return 了，这种情况下，JS 引擎会将父函数的上下文从执行栈中移除，与此同时，JS 引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS 引擎才会将子函数的上下文及闭包一并从执行栈中移除。")]),t._v(" "),s("p",[t._v("最后，JS 引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时 JS 是如何执行的。比如 setTimeout 或 fetch 请求都是 non-blocking 的，当异步调用代码触发时，JS 引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS 引擎会立即将与之对应的回调函数 push 进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS 引擎会立刻将任务队列中的回调函数逐个 push 进调用栈并执行。这个过程我们也称之为事件循环。")]),t._v(" "),s("h2",{attrs:{id:"links"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000022095740#item-2",target:"_blank",rel:"noopener noreferrer"}},[t._v("了解 v8 引擎吗，一段 js 代码如何执行的"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);