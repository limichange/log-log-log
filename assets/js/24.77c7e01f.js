(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{370:function(e,t,a){"use strict";a.r(t);var r=a(43),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"script-标签的-defer-和-async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#script-标签的-defer-和-async"}},[e._v("#")]),e._v(" script 标签的 defer 和 async")]),e._v(" "),a("h2",{attrs:{id:"defer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[e._v("#")]),e._v(" defer")]),e._v(" "),a("p",[e._v("这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在"),a("code",[e._v("<script>")]),e._v("元素中设置 "),a("code",[e._v("defer")]),e._v(" 属性，相当于告诉浏览器立即下载，但延迟执行。")]),e._v(" "),a("p",[a("code",[e._v("HTML5")]),e._v(" 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 "),a("code",[e._v("DOMContentLoaded")]),e._v(" 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 "),a("code",[e._v("DOMContentLoad")]),e._v(" 时间触发前执行，因此最好只包含一个延迟脚本。")]),e._v(" "),a("p",[e._v("我们可以认为是将外链的 js 放在了页面底部。js 的加载不会阻塞页面的渲染和资源的加载。不过 defer 会按照原本的 js 的顺序执行，所以如果前后有依赖关系的 js 可以放心使用。")]),e._v(" "),a("h2",{attrs:{id:"async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[e._v("#")]),e._v(" async")]),e._v(" "),a("p",[e._v("这个属性与 "),a("code",[e._v("defer")]),e._v(" 类似，都用于改变处理脚本的行为。同样与 "),a("code",[e._v("defer")]),e._v(" "),a("code",[e._v("类似，async")]),e._v(" 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 "),a("code",[e._v("defer")]),e._v(" 不同的是，标记为 "),a("code",[e._v("async")]),e._v(" 的脚本并不保证按照它们的先后顺序执行。")]),e._v(" "),a("p",[e._v("第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。")]),e._v(" "),a("p",[e._v("这个是 html5 中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行在有 async 的情况下，js 一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 js 前后有依赖性，用 async，就很有可能出错。")]),e._v(" "),a("h2",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[e._v("#")]),e._v(" 区别")]),e._v(" "),a("p",[e._v("概括来讲，就是这两个属性都会使 script 标签异步加载，然而执行的时机是不一样的")]),e._v(" "),a("h3",{attrs:{id:"相同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[e._v("#")]),e._v(" 相同点")]),e._v(" "),a("ul",[a("li",[e._v("加载文件时不阻塞页面渲染")]),e._v(" "),a("li",[e._v("对于 inline 的 script（内联脚本）无效")]),e._v(" "),a("li",[e._v("使用这两个属性的脚本中不能调用 document.write 方法")]),e._v(" "),a("li",[e._v("有脚本的 onload 的事件回调")])]),e._v(" "),a("h3",{attrs:{id:"不同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[e._v("#")]),e._v(" 不同点")]),e._v(" "),a("ul",[a("li",[e._v("html 的版本 html4.0 中定义了 defer；html5.0 中定义了 async")]),e._v(" "),a("li",[e._v("执行时刻每一个 async 属性的脚本都在它下载结束之后立刻执行，同时会在 window 的 load 事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个 defer 属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在 document 的 DOMContentLoaded 之前执行。")])]),e._v(" "),a("h2",{attrs:{id:"结论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[e._v("#")]),e._v(" 结论")]),e._v(" "),a("ul",[a("li",[e._v("如果 async 为 true，那么脚本在下载完成后异步执行。")]),e._v(" "),a("li",[e._v("如果 async 为 false，defer 为 true，那么脚本会在页面解析完毕之后执行。")]),e._v(" "),a("li",[e._v("如果 async 和 defer 都为 false，那么脚本会在页面解析中，停止页面解析，立刻下载并且执行。")])]),e._v(" "),a("h2",{attrs:{id:"links"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" links")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000006778717",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈 script 标签的 defer 和 async"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5a1229596fb9a0451704cae8",target:"_blank",rel:"noopener noreferrer"}},[e._v("script 中 defer 和 async 的区别"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);