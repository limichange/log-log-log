(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{593:function(t,_,a){"use strict";a.r(_);var v=a(43),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-性能优化"}},[t._v("#")]),t._v(" React 性能优化")]),t._v(" "),a("p",[t._v("2")]),t._v(" "),a("h2",{attrs:{id:"main"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#main"}},[t._v("#")]),t._v(" main")]),t._v(" "),a("ul",[a("li",[t._v("减少计算的量。 -> 对应到 React 中就是减少渲染的节点 或者 降低组件渲染的复杂度")]),t._v(" "),a("li",[t._v("利用缓存。-> 对应到 React 中就是如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染")]),t._v(" "),a("li",[t._v("精确重新计算的范围。 对应到 React 中就是绑定组件和状态关系, 精确判断更新的'时机'和'范围'. 只重新渲染'脏'的组件，或者说降低渲染范围")])]),t._v(" "),a("h2",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[t._v("#")]),t._v(" list")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("减少渲染的节点/降低渲染计算量(复杂度)")]),t._v(" "),a("ul",[a("li",[t._v("0️⃣ 不要在渲染函数都进行不必要的计算")]),t._v(" "),a("li",[t._v("1️⃣ 减少不必要的嵌套")]),t._v(" "),a("li",[t._v("2️⃣ 虚拟列表")]),t._v(" "),a("li",[t._v("3️⃣ 惰性渲染")]),t._v(" "),a("li",[t._v("4️⃣ 选择合适的样式方案")])])]),t._v(" "),a("li",[a("p",[t._v("避免重新渲染")]),t._v(" "),a("ul",[a("li",[t._v("0️⃣ 简化 props")]),t._v(" "),a("li",[t._v("1️⃣ 不变的事件处理器")]),t._v(" "),a("li",[t._v("2️⃣ 不可变数据")]),t._v(" "),a("li",[t._v("3️⃣ 简化 state")]),t._v(" "),a("li",[t._v("4️⃣ 使用 recompose 精细化比对")])])]),t._v(" "),a("li",[a("p",[t._v("精细化渲染")]),t._v(" "),a("ul",[a("li",[t._v("0️⃣ 响应式数据的精细化渲染")]),t._v(" "),a("li",[t._v("1️⃣ 不要滥用 Context")])])])]),t._v(" "),a("h2",{attrs:{id:"links"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.im/post/5d045350f265da1b695d5bf2",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈 React 性能优化的方向"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=e.exports}}]);