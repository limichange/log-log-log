(window.webpackJsonp=window.webpackJsonp||[]).push([[261],{605:function(t,e,a){"use strict";a.r(e);var r=a(43),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"比较-react-和-vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比较-react-和-vue"}},[t._v("#")]),t._v(" 比较 React 和 Vue")]),t._v(" "),a("h2",{attrs:{id:"监听数据变化的实现原理不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监听数据变化的实现原理不同"}},[t._v("#")]),t._v(" 监听数据变化的实现原理不同")]),t._v(" "),a("ul",[a("li",[t._v("Vue 通过 getter/setter 以及一些函数，能精确知道数据变化")]),t._v(" "),a("li",[t._v("React 默认是通过比较引用的方式(diff)进行的，React 不精确监听数据变化")])]),t._v(" "),a("h2",{attrs:{id:"数据流不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据流不同"}},[t._v("#")]),t._v(" 数据流不同")]),t._v(" "),a("ul",[a("li",[t._v("Vue2.0 可以通过 props 实现双向绑定，用 vuex 单向数据流的状态管理框架")]),t._v(" "),a("li",[t._v("React 不支持双向绑定，提倡单项数据流，Redux 单向数据流的状态管理框架")])]),t._v(" "),a("h2",{attrs:{id:"组件通信的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件通信的区别"}},[t._v("#")]),t._v(" 组件通信的区别")]),t._v(" "),a("h3",{attrs:{id:"vue-三种组件通信方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-三种组件通信方法"}},[t._v("#")]),t._v(" Vue 三种组件通信方法")]),t._v(" "),a("p",[t._v("父组件通过 props 向子组件传递数据或回调")]),t._v(" "),a("p",[t._v("子组件通过事件 event 向父组件发送数据或回调")]),t._v(" "),a("p",[t._v("通过 provide/inject 实现父组件向子组件传入数据，可跨层级")]),t._v(" "),a("h3",{attrs:{id:"react-三种组件通信方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-三种组件通信方法"}},[t._v("#")]),t._v(" React 三种组件通信方法")]),t._v(" "),a("p",[t._v("父组件通过 props 向子组件传递数据")]),t._v(" "),a("p",[t._v("React 不支持子组件像父组件发送数据，而使用的是回调函数")]),t._v(" "),a("p",[t._v("通过 context 实现父组件向子组件传入数据， 可跨层级")]),t._v(" "),a("h2",{attrs:{id:"jsx-与-html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx-与-html"}},[t._v("#")]),t._v(" JSX 与 HTML")]),t._v(" "),a("p",[t._v("React 使用 JSX - 一种声明性 JavaScript XML，允许开发人员利用 JavaScript 的强大功能编写组件，而 Vue.js 使用 HTML 模板创建视图。\n基于 HTML 的模板更加熟悉，在改进现有应用程序以获得 Vue 反应性功能的好处方面也是有益的。这为初学者和有经验的专业人士提供了一个简单的学习曲线，因为他们中的大多数人都以这种或那种方式使用 HTML。")]),t._v(" "),a("h2",{attrs:{id:"模板中使用的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板中使用的数据"}},[t._v("#")]),t._v(" 模板中使用的数据")]),t._v(" "),a("ul",[a("li",[t._v("React 里模板中使用的数据可以直接 import 的组件在 render 中调用")]),t._v(" "),a("li",[t._v("Vue 里模板中使用的数据必须要在 this 上进行中转，还要 import 一个组件，还要在 components 中声明")])]),t._v(" "),a("p",[t._v("在像 React 和 Vue 这样的基于组件的框架中，当您开始扩展应用程序时，需要更加关注状态管理和数据流。这是因为有许多组件相互交互并共享数据。\n在这种情况下，React 提供了一种称为 Flux / Redux 架构的创新解决方案，它代表单向数据流，是着名 MVC 架构的替代方案。现在，如果我们考虑 Vue.js 框架，就会有一个名为 Vuex 的更高级架构，它集成到 Vue 中并提供无与伦比的体验。")]),t._v(" "),a("h2",{attrs:{id:"links"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[t._v("#")]),t._v(" links")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000021698504#item-5",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何比较 React 和 Vue?"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);